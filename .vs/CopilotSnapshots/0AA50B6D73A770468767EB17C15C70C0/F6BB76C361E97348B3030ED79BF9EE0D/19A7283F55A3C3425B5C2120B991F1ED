namespace ExpenseTracker.Application.Services;

using ExpenseTracker.Application.DTOs;
using ExpenseTracker.Application.Interfaces;
using ExpenseTracker.Domain.Common;
using ExpenseTracker.Domain.Entities;
using ExpenseTracker.Domain.Entities.Enums;
using ExpenseTracker.Infrastructure.Repositories;
using System.Linq;

/// <summary>
/// Serviço de transações da aplicação.
/// Implementa regras de negócio referentes à criação de transações e relatórios.
/// </summary>
public class TransactionService : ITransactionService
{
    private readonly ITransactionRepository _transactionRepository;
    private readonly IPersonRepository _personRepository;
    private readonly ICategoryRepository _categoryRepository;

    public TransactionService(
        ITransactionRepository transactionRepository,
        IPersonRepository personRepository,
        ICategoryRepository categoryRepository)
    {
        _transactionRepository = transactionRepository;
        _personRepository = personRepository;
        _categoryRepository = categoryRepository;
    }

    /// <summary>
    /// Cria uma transação após validar regras de idade e compatibilidade de categoria.
    /// </summary>
    public async Task<Result<TransactionResponse>> CreateTransactionAsync(CreateTransactionRequest request)
    {
        // Buscar pessoa e categoria
        var person = await _personRepository.GetByIdAsync(request.PersonId);
        if (person == null) return Result<TransactionResponse>.Error("Pessoa não encontrada");

        var category = await _categoryRepository.GetByIdAsync(request.CategoryId);
        if (category == null) return Result<TransactionResponse>.Error("Categoria não encontrada");

        // Regra de idade: menores de 18 não podem registrar receitas
        if (request.Type == TransactionType.Revenue && person.Age < 18)
            return Result<TransactionResponse>.Warning(default, "Menores de 18 anos não podem registrar receitas.");

        // Regra de categoria:
        // - Se for Expense, categoria não pode ser apenas Revenue
        if (request.Type == TransactionType.Expense && category.Purpose == CategoryPurpose.Revenue)
            return Result<TransactionResponse>.Error("A categoria selecionada não suporta transações de despesa.");

        // - Se for Revenue, categoria não pode ser apenas Expense
        if (request.Type == TransactionType.Revenue && category.Purpose == CategoryPurpose.Expense)
            return Result<TransactionResponse>.Error("A categoria selecionada não suporta transações de receita.");

        // Todas as validações passaram, criar a entidade e persistir
        var transaction = Transaction.Create(
            request.Description,
            request.Value,
            request.Type,
            request.CategoryId,
            request.PersonId,
            category,
            person);

        await _transactionRepository.AddAsync(transaction);
        await _transactionRepository.UnitOfWork.SaveChangesAsync();

        var response = new TransactionResponse(transaction.Id, transaction.Description, transaction.Value, transaction.Type, transaction.CategoryId, transaction.PersonId, transaction.CreatedAt);
        return Result<TransactionResponse>.Success(response);
    }

    /// <summary>
    /// Retorna o resumo por pessoa (somas de receitas, despesas e saldo líquido).
    /// </summary>
    public async Task<Result<IEnumerable<PersonSummaryResponse>>> GetSummaryByPersonAsync()
    {
        // Obter transações agrupadas por pessoa e calcular somas de forma eficiente
        var summaries = await _transactionRepository
            .Query()
            .GroupBy(t => new { t.PersonId, t.Person!.Name })
            .Select(g => new PersonSummaryResponse(
                g.Key.PersonId,
                g.Key.Name,
                g.Where(t => t.Type == TransactionType.Revenue).Sum(t => t.Value),
                g.Where(t => t.Type == TransactionType.Expense).Sum(t => t.Value),
                g.Where(t => t.Type == TransactionType.Revenue).Sum(t => t.Value) - g.Where(t => t.Type == TransactionType.Expense).Sum(t => t.Value)
            ))
            .ToListAsync();

        return Result<IEnumerable<PersonSummaryResponse>>.Success(summaries);
    }

    /// <summary>
    /// Retorna o resumo por categoria (somas de receitas, despesas e saldo líquido).
    /// </summary>
    public async Task<Result<IEnumerable<CategorySummaryResponse>>> GetSummaryByCategoryAsync()
    {
        var summaries = await _transactionRepository
            .Query()
            .GroupBy(t => new { t.CategoryId, t.Category!.Description })
            .Select(g => new CategorySummaryResponse(
                g.Key.CategoryId,
                g.Key.Description,
                g.Where(t => t.Type == TransactionType.Revenue).Sum(t => t.Value),
                g.Where(t => t.Type == TransactionType.Expense).Sum(t => t.Value),
                g.Where(t => t.Type == TransactionType.Revenue).Sum(t => t.Value) - g.Where(t => t.Type == TransactionType.Expense).Sum(t => t.Value)
            ))
            .ToListAsync();

        return Result<IEnumerable<CategorySummaryResponse>>.Success(summaries);
    }

    /// <summary>
    /// Retorna o resumo geral (total de receitas, total de despesas e saldo líquido).
    /// </summary>
    public async Task<Result<ReportSummaryResponse>> GetOverallSummaryAsync()
    {
        var q = _transactionRepository.Query();
        var totalRevenue = await q.Where(t => t.Type == TransactionType.Revenue).SumAsync(t => t.Value);
        var totalExpense = await q.Where(t => t.Type == TransactionType.Expense).SumAsync(t => t.Value);
        var net = totalRevenue - totalExpense;
        return Result<ReportSummaryResponse>.Success(new ReportSummaryResponse(totalRevenue, totalExpense, net));
    }
}
